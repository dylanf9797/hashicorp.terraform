---
page_title: resource block configuration reference
description: The `resource` block instructs Terraform to create an infrastructure resource. Learn about the arguments and attributes you can define in the `resource` block.

---

# `resource` block

This topic provides reference information about the arguments Terraform natively supports in the `resource` block. Refer to the provider documentation for information about arguments specific to the providers you import.

## Introduction

Add `resource` blocks to your Terraform configuration to describe one or more infrastructure objects, such as virtual networks, compute instances, or higher-level components such as DNS records. Refer to [Create and manage resources]() for additional information.

## Configuration model

The following outline lists the nested blocks and arguments you can define in the `resource` block. Click on an element for details.

- [`resource "<TYPE>" "<LABEL>"`](#resource): block
   - [`PROVIDER_ARGUMENTS`](#provider_arguments)
   - [`count`](#count): number 
   - [`depends_on`](#depends_on): list or references
   - [`for_each`](#for_each): function
      - [`tomap()`](#for_each): map of key-value pairs
      - [`toset()`](#for_each): list of string values 
   - [`provider`](#provider): reference
   - [`lifecycle`](#lifecycle): block
      - [`create_before_destroy`](#create_before_destroy): boolean
      - [`prevent_destroy`](#prevent_destroy): boolean
      - [`ignore_changes`](#ignore_changes): list of attribute names
      - [`replace_triggered_by`](#replace_triggered_by): list of references
      - [`precondition`](#precondition): block
      - [`postcondition`](#postcondition): block
   - [`provisioner "<TYPE>" "<LABEL>"`](#provisioner): block 

## Complete configuration

When every argument, attribute, and nested block is defined, a `resource` block has the following form:

```hcl
resource "<TYPE>" "<LABEL>" {
  <PROVIDER_ARGUMENTS>
  count = <number>
  depends_on = [ <resource.address.expression> ]
  for_each = tomap({
    <KEY> = <VALUE>
  })
  for_each = toset([
    "<VALUE>", 
    "<VALUE>"
  ])
  provider = <reference.to.alias>
  lifecycle {
    create_before_destroy = <true || false>
    prevent_destroy = <true || false>
    ignore_changes = [ <ATTRIBUTE> ]
    replace_triggered_by = [ <resource.address.expression> ]
    precondition {
      condition = <EXPRESSION>
      error_message = "<STRING>"
    }
    postcondition {
      condition = <EXPRESSION>
      error_message = "<STRING>"
    }
  }
  provisioner "<TYPE>" "<LABEL>" {
    <PROVISIONER_ARGUMENTS>
  }
}
```


## Specification

This section provides details about the nested blocks and arguments you can configure in the `resource` block. Specific providers and backends may support additional fields.

### `resource`

The main `resource` block accepts the following attributes:

- `TYPE`: Specifies the type of resource you can declare. The type depends on the provider you import. Refer to the documentation for your provider for details. You can also specify the `terraform_data` resource type to implement a standard resource lifecycle. Refer [Implement the standard resource lifecycle](linky-link) for additional information
- `LABEL`: Specifies an arbitrary name for the resource that you can use to reference the resource from other configuration elements. Refer to [Resource naming](/terraform/language/style#resource-naming) in the style guide for label recommendations.

### `PROVIDER_ARGUMENTS`

Add the arguments specific to the provider you want to use in your configuration to the [`resource`](#resource) block. Refer to the documentation for your provider for details.  

- Data type: Determined by provider
- Default: None
- Child of: [`resource`](#resource)

### `count`

Add the `count` argument to the [`resource`](#resource) block. The `count` argument provisions the specified number of identical resources. Use this argument to create a pool of distinct resource objects that have the same configuration. Refer to [Create multiple instances of a resource](#create-multiple-instances-of-a-resource) for an example.

You cannot specify references to resource attributes, such as a unique ID generated by the cloud provider when it creates the object. Instead, specify a whole number value prior to creating the resource so that the provider can create the specified number of instances. 

The `count` argument exposes a `count` object that you can reference elsewhere in the configuration to modify specific instances. You can reference instances using the `<TYPE>.<NAME>[INDEX]` format. For example, `aws_instance.server[0]` refers to the first instance of the `aws_instance` resource named `server`.  Refer to [Create and manage resources]() for additional information.

The `count` argument is a meta-argument, which refers to arguments that you can use in modules, as well as in any type of resource. Refer to [Meta-arguments](/terraform/language/concepts/meta-arguments) for additional information.

- Data type: Number. 
- Default: None. Terraform provisions a single instance by default.  
- Child of: [`resource`](#resource).
- Example: [Create multiple instances of a resource](#create-multiple-instances-of-a-resource).

### `depends_on`

Add the `depends_on` argument to the [`resource`](#resource) block. The `depends_on` argument specifies actions that Terraform must complete before performing operations associated with the resource. Use the `depends_on` argument when Terraform is unable to infer a dependency automatically but the resource depends on data in the other object's arguments. Refer to [Specify a dependency](#specify-a-dependency) for an example configuration.

You can specify a list of references to other resources or child modules in the same calling module. Arbitrary expressions are not allowed. This is because the value referenced in the `depends_on` argument must be available so that Terraform can determine resource relationships and can safely evaluate expressions.

Specifying an entire module in the `depends_on` argument affects the order in which Terraform processes all of the resources and data sources associated with that module. Refer to  [Resource dependencies](/terraform/language/manage-resources#resource-dependencies) 
and [Data resource dependencies](/terraform/language/configure-data-sources#data-resource-dependencies) for additional information.

We recommend always including a comment that explains why using `depends_on` is necessary.

The `depends_on` argument is a meta-argument argument. You can use meta-arguments in `module` blocks and in all `resource` blocks, regardless of resource type. Refer to [Meta-arguments](/terraform/language/concepts/meta-arguments) for additional information. 

- Data type: Reference. Refer to [References to Named Values](/terraform/reference/language/expressions/references) for syntax  
- Default: None. Terraform follows the dependency graph to determine dependencies. Refer to [internals](/terraform/language/internals) for additional information. 
- Child of: [`resource`](#resource).
- Example: [Specify a dependency](#specify-a-dependency).

### `for_each`

Add the `for_each` argument to the [`resource`](#resource) block. The `for_each` argument provisions a set of similar resources without writing separate blocks of configuration. Refer to [Create multiple instances of a resource](#create-multiple-instances-of-a-resource) for an example configuration.

You can specify the following values `for_each` argument:

- `tomap()`: Function that accepts a map of key-value pairs. Terraform creates a resource for each pair in the function using the configurations specified in the `resource` block. Refer to the [`tomap()` function reference](/terraform/language/functions/tomap) for additional information.
- `toset()`: Function that accepts a list of string values. Terraform creates a resource for each item in the function using the configurations specified in the `resource` block. Refer to the [`toset()` function reference](/terraform/language/functions/toset) for additional information.
- Reference expression: Terraform creates a resource for each item defined in the referenced object using the configurations specified in the resource block. Refer to [References to Named Values](/terraform/reference/language/expressions/references) for syntax.   

Terraform cannot derive keys in the `for_each` argument from functions because it defers evaluation during the main evaluation step. Terraform must have a record of the keys, values in the list, or referenced objects in the `for_each` argument. Otherwise, Terraform prints an error message. The error message states that the argument has dependencies that Terraform cannot determine before running the `terraform apply` command and that you may need to add a `-target` flag. 

You cannot specify sensitive data in `for_each` blocks. Terraform prints an error message when it detects sensitive data in the argument. You can transform a value containing sensitive data into an argument supported by the `for_each` field, but Terraform returns a sensitive result. Refer to [Sensitive Data in State](/terraform/language/state/sensitive-data) for additional information.

The `for_each` argument does not implicitly convert lists or tuples to sets. To declare resource instances based on a nested data structure or combinations of elements from multiple data structures, you can use Terraform expressions and functions to derive a suitable value. Refer to the following examples for additional information:

- [Transform a multi-level nested structure into a flat list](/terraform/language/functions/flatten#flattening-nested-structures-for-for_each)
- [Combine collections to produce a list of element combinations](/terraform/language/functions/setproduct#finding-combinations-for-for_each).

The `for_each` argument exposes an `each` object that you can reference elsewhere in the configuration to modify specific instances. The `each` object has the following attributes:

- `key`: Map or list member that corresponds to an instance.
- `value`: Map value that corresponds to an instance. 

Use the `<TYPE>.<NAME>[<KEY>]` format to reference an instance. For example, `azurerm_resource_group.rg["a_group"]` refers to an instance of the `azurrm_resource_group` resource named `a_group`.

The `for_each` argument is a meta-argument. You can use meta-arguments in modules, as well as in any type of resource. Refer to [Meta-arguments](/terraform/language/concepts/meta-arguments) for additional information.

- Data type: Function or reference expression. 
- Default: None. Terraform provisions a single instance by default.  
- Child of: [`resource`](#resource)
- Example: [Create multiple instances of a resource](#create-multiple-instances-of-a-resource). 

### `provider`

Add the `provider` argument to the [`resource`](#resource) block. The `provider` argument instructs Terraform to use an alternate provider configuration to provision the resource. Refer to [Select an alternate provider configuration](#select-an-alternate-provider-configuration) for an example.

By default, Terraform automatically selects a provider based on the resource type, but you can create multiple provider configurations and select a specific configuration for the resources in the configuration. 

Use the `<PROVIDER>.<ALIAS>` format to reference a provider configuration in the `provider` argument. You must specify the `alias` argument in the `provider` block. Refer to [`provider` reference](/terraform/language/provider) for details.   

The `provider` argument is a meta-argument, which refers to arguments that you can use in modules, as well as in any type of resource. Refer to [Meta-arguments](/terraform/language/concepts/meta-arguments) for additional information.

- Data type: Reference.
- Default: None. Terraform automatically selects a provider based on the resource type by default. 
- Child of: [`resource`](#resource).
- Example: [Select an alternate provider configuration](#select-an-alternate-provider-configuration).

### `lifecycle`

Add the `lifecycle` block to the [`resource`](#resource) block. The `lifecycle` block defines the resource's infrastructure lifecycle type. The infrastructure lifecycle refers to one or more operations that Terraform performs to manage the resource. You can specify the following types of lifecycles:

- [`create_before_destroy`](#create_before_destroy): Terraform creates a replacement object before destroying the previous object.
- [`prevent_destroy`](#prevent_destroy): Terraform rejects operations that destroy infrastructure objects associated with the resource and returns an error.
- [`ignore_changes`](#ignore_changes): Terraform ignores changes to the resource configuration. As a result, the remote resource under management remains unchanged.
- [`replace_triggered_by`](#replace-triggered_by): Terraform replaces the resource when any of the specified items change.
- [`precondition`](#precondition): Specifies an existing condition that triggers a check on the resource. Refer to [Create checks](linky-ti-link) for additional information.
- [`postcondition`](#postcondition): Specifies a condition that emerges after a Terraform operation that triggers a check on the resource. Refer to [Create checks](linky-ti-link) for additional information.

Configurations defined in the `lifecycle` block affect how Terraform constructs and traverses the dependency graph. You can only use literal values because Terraform processes the configurations before it is able to evaluate arbitrary expressions.

The `lifecycle` block, and lifecycle types it specifies, is a meta-argument. You can add meta-arguments to modules and to any type of resource. Refer to [Meta-arguments](/terraform/language/concepts/meta-arguments) for additional information.  

- Data type: Block.
- Default: Terraform applies the standard lifecycle. Refer to [Apply the standard resource lifecycle](#) for additional information.
- Child of: [`resource`](#resource)

### `create_before_destroy`

Add the `create_before_destroy` argument to the [`lifecycle`](#lifecycle) block. The `create_before_destroy` argument creates a replacement resource before destroying the object it replaces. By default, Terraform destroys an object before creating a new instance to replace it. 

Refer to the documentation for the resource type you are configuring before setting the `create_before_destroy` argument. The resource may have unique constraints, such as name requirements, that you must accommodate for the created and destroyed object to exist concurrently. Some resource types offer special options to append a random suffix onto each object name to  avoid collisions, for example. Terraform cannot automatically activate these types of features.

Terraform propagates and applies the `create_before_destroy` behavior to all resource dependencies. For example, if `create_before_destroy` is enabled on resource A but not on resource B, but resource A is dependent on resource B, then Terraform enables `create_before_destroy` for resource B implicitly and stores it to the state file. You cannot override `create_before_destroy` to `false` on resource B because that would imply dependency cycles in the graph.

When `create_before_destroy` is set to `true`, a provisioner that would normally destroy the resource does not run. Refer to the GitHub issue titled ["on-destroy provisioners not being executed"](https://github.com/hashicorp/terraform/issues/13549) for details.

- Data type: Boolean
- Default: None. By default, Terraform destroys an object before creating its replacement.
- Child of: [`lifecycle`](#lifecycle) block.  

### `prevent_destroy`

Add the `prevent_destroy` argument to the `lifecycle` block. The `prevent_destroy` argument rejects plans that would destroy the infrastructure object associated with the resource. Use this argument to prevent team members from accidentally replacing an object that is costly to reproduce, such as database instances.

When the `prevent_destroy` arugment is set, you must either remove the resource from the configuration or change the `prevent_destroy` argument to `false` to destroy it. 

Use this argument with caution because it makes some configuration changes impossible to apply and prevents you from using the `terraform destroy` command on the configuration.

- Data type: Boolean
- Default: None.  
- Child of: [`lifecycle`](#lifecycle) block.  

### `ignore_changes`

Add the `ignore_changes` argument to the [`lifecycle`](#lifecycle) block. The `ignore_changes` argument specifies a list of resource attributes for Terraform to ignore when planning updates to the remote object. Use this argument when the resource references data that may change but does not affect the resource after its creation. Refer to [Ignore attribute changes](#ignore-attribute-changes) for an example.

Terraform logs the specified arguments corresponding to the remote resource attribute names when planning a `create` operation, but it ignores the arguments when planning an `update` operation. You can specify arguments as the relative attribute addresses in the resource. You can specify members of maps and lists using index notation, such as `tags["Name"]` and `list[0]`. 

You can also specify the `all` instead of a list. The `all` keyword instructs Terraform to ignore all attributes. As a result, Terraform can create and destroy the remote object but it does not  propose updates to the object. 

- Data type: List of attributes.
- Default: None. By default, Terraform detects any difference in the current settings of a real infrastructure object and plans to update the remote object to match the configuration.
- Child of: [`lifecycle`](#lifecycle) block.
- Example: [Ignore attribute changes](#ignore-attribute-changes).

### `replace_triggered_by`

Add the `replace_triggered_by` argument to the [`lifecycle`](#lifecycle) block. The `replace_triggered_by` argument replaces the resource when any of the referenced items change. Refer to [Specify triggers that replace resources](#specify-triggers-that-replace-resources) for an example configuration.

You can specify a list of expressions that reference managed resources, instances, or instance attributes. You can only reference managed resources in `replace_triggered_by` expressions. This lets you modify these expressions without forcing replacement.

The trigger is based on the planned actions for all of the given resources. Terraform does not plan actions for plain values, such as local values or input variables, but you can apply [the `terraform_data` resource type](/terraform/language/resources/terraform-data) so that Terraform applies a resource-like lifecycle to them.

The argument triggers a replacement resource under following conditions:

- When the reference points to a resource with multiple instances, a `terraform plan` command to update or replace any instance triggers replacement.
- When the reference points to a single resource instance, a `terraform plan` command to update or replace that instance triggers replacement.
- When the reference points to a single attribute of a resource instance, any change to the attribute value triggers replacement.

Adding the `replace_triggered_by` argument to a resource that uses `count` or `for_each` lets you add the `count.index` or `each.key` resource address to the expression. Use this address segment to reference specific instances of other resources that are configured with the same `count` or collection.

- Data type: List of resource address references
- Default: None.
- Child of: [`lifecycle`](#lifecycle) block.
- Example: [Specify triggers that replace resources](#specify-triggers-that-replace-resources)  

### `precondition`

Add the `precondition` block to the [`lifecycle`](#lifecycle) block. The `precondition` block specifies a condition that must return `true` before Terrafom evaluates the objects associated with the resource. You can also specify an error message for Terraform to print when the condition returns `false`. Refer to [Apply custom conditions](#apply-custom-conditions) for an example configuration.

You can specify the following attributes in the `precondition` block:

| Attribute | Description | Data type |
| --- | --- | --- |
| `condition` | Expression that must return `true` for Terraform to proceed with an operation. You can refer to any other object in the same configuration scope unless the reference creates a cyclic dependency. | Expression that can include references, strings, and operators. |
| `error_message` | Message that Terraform prints to the console if the `condition` returns `false`. | String |

Terraform evaluates precondition blocks after evaluating existing `count` and `for_each` arguments. Doing so lets Terraform evaluate the `precondition` separately for each instance and then make the `each.key` and `count.index` objects  available in the conditions. 

Terraform evaluates `precondition` blocks before evaluating the resource's configuration arguments. The `precondition` can take precedence over argument evaluation errors.

You can include a `precondition` and [`postcondition` block](#postcondition) in the same resource.

Do not add `precondition` blocks to a `resource` block and a `data` block that represent the same object in the same configuration. Doing so can prevent Terraform from understanding that the data block result can be affected by changes in the resource block. 

Refer to [Create custom conditions](link to usage page) for information about adding validations to your Terraform configuration.

- Data type: Block.
- Default: None.
- Child of: [`lifecycle`](#lifecycle) block
- Exampe: [Apply custom conditions](#apply-custom-conditions)

### `postcondition`

Add the `postcondition` block to the [`lifecycle`](#lifecycle) block. The `postcondition` block specifies a condition that must return `true` after Terrafom evaluates the objects associated with the resource. You can also specify an error message for Terraform to print to the console when the condition returns `false`. Refer to [Apply custom conditions](#apply-custom-conditions) for an example configuration.

You can specify the following attributes in the `precondition` block:

| Attribute | Description | Data type |
| --- | --- | --- |
| `condition` | Expression that must return `true` for Terraform to proceed with an operation. You can refer to any other object in the same configuration scope unless the reference creates a cyclic dependency. | Expression that can include references, strings, and operators. |
| `error_message` | Message that Terraform prints to the console if the `condition` returns `false`. | String |

Refer to [Create custom conditions](link to usage page) for information about adding validations to your Terraform configuration.

Terraform evaluates `postcondition` blocks after planning and applying changes to a managed resource. Postcondition failures prevent changes to other resources that depend on the failing resource.

You can include a `postcondition` and [`precondition` block](#precondition) in the same resource.

Do not add `postcondition` blocks to a `resource` block and a `data` block that represent the same object in the same configuration. Doing so can prevent Terraform from understanding that the data block result can be affected by changes in the resource block. 

- Data type: Block.
- Default: None.
- Child of: [`lifecycle`](#lifecycle) block
- Exampe: [Apply custom conditions](#apply-custom-conditions)

### `provisioner`

Add the `provisioner` block to the [`resource`](#resource) block. The `provisioner` block contains a set of attributes that let you model specific actions on the local or remote machine, such as preparing servers or other infrastructure objects for service. The `provisioner` argument has the following attributes:

 `TYPE`: Specifies one of the following provisioner types:
  - `file`: Copies files or directories form the machine where Terraform is running to the new resource.
  - `local-exec`: Invokes an executable on the local machine after Terraform creates the resource.
  - `remote-exec`: Invokes an executable on the remote resource after Terraform creates the resource.  
- `LABEL`: Optional attribute for adding a unique name. Refer to [Resource naming](/terraform/language/style#resource-naming) in the style guide for label recommendations.

Refer to the [`provisioner` block reference]() for additional information.

- Data type: Block.
- Default: None.
- Child of: [`resource`](#resource) block.


## Examples

The following examples describe common patterns for specific use cases.

### Define an AWS instance

The following example defines an `aws_instance` resource named `web`. 

```hcl
resource "aws_instance" "web" {
  ami           = "ami-a1b2c3d4"
  instance_type = "t2.micro"
}
```

### Create multiple instances of a resource

You can use either the `count` or `for_each` block to create multiple instances of a resource. The `count` argument is most suitable for creating multiple instances that are identical or nearly identical. The `for_each` argument is most suitable for creating multiple instances that you can reference by name instead of index number to provide distinct values.

<Tabs>

<Tab heading="count"> 

The following example creates one instance for each subnet:

```hcl
variable "subnet_ids" {
  type = list(string)
}

resource "aws_instance" "server" {

  count = length(var.subnet_ids)

  ami           = "ami-a1b2c3d4"
  instance_type = "t2.micro"
  subnet_id     = var.subnet_ids[count.index]

  tags = {
    Name = "Server ${count.index}"
  }
}
```

</Tab>

<Tab heading="for_each">

The following example creates two instances using the `tomap()` function:

```hcl
resource "azurerm_resource_group" "rg" {
  for_each = tomap({
    a_group       = "eastus"
    another_group = "westus2"
  })
  name     = each.key
  location = each.value
}
```

The following example creates four instances using the `toset()` function:

```hcl
resource "aws_iam_user" "the-accounts" {
  for_each = toset(["Todd", "James", "Alice", "Dottie"])
  name     = each.key
}
```

In the following example, Terraform creates two AWS S3 buckets using a child module defined in `my_buckets.tf`.  The `variable "name" {}` configuration defines the module's input parameter. Because `var.name` includes `each.key` when Terraform calls the module to provision an instance, the value changes for each instance.

<CodeBlockConfig filename="my_buckets.tf">

```hcl
module "bucket" {
  for_each = toset(["assets", "media"])
  source   = "./publish_bucket"
  name     = "${each.key}_bucket"
}
```

</CodeBlockConfig>

<CodeBlockConfig filename="publish_bucket/bucket-and-cloudfront.tf">

```hcl
variable "name" {} 
resource "aws_s3_bucket" "example" {
   bucket = var.name
   #...
}

resource "aws_iam_user" "deploy_user" {
   #...
}
```
 
</CodeBlockConfig> 

</Tab>

</Tabs>

### Specify a dependency

This example contains several configurations to illustrate how to specify a dependency.

The following `resource` block partially defines an `aws_iam_role` resource. Refer to the [AWS provider documentation](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_role) all configuration settings. 

```hcl
resource "aws_iam_role" "example" {
  name = "example"
  assume_role_policy = "..."
}
```

In the following `resource` block, Terraform infers that it must create the role for the `aws_iam_instance_profile` before creating the resource. This is because the `role` argument is defined with an expression:

```hcl
resource "aws_iam_instance_profile" "example" {
  role = aws_iam_role.example.name
}
```

The following `resource` block configures an IAM policy that allows software running on the EC2 instance to access the S3 API.

```hcl
resource "aws_iam_role_policy" "example" {
  name   = "example"
  role   = aws_iam_role.example.name
  policy = jsonencode({
    "Statement" = [{     
      "Action" = "s3:*",
      "Effect" = "Allow",
    }],
  })
}
```

Terraform infers that it must create the instance profile before the EC2 instance, but it cannot infer that the software running in the EC2 instance needs access to the S3 API in order to boot properly. As a result, the configuration explicitly instructs Terraform to create the `aws_iam_role_policy` first:

```hcl
resource "aws_instance" "example" {
  ami           = "ami-a1b2c3d4"
  instance_type = "t2.micro"
  iam_instance_profile = aws_iam_instance_profile.example
  depends_on = [
    aws_iam_role_policy.example
  ]
}
```

### Select an alternate provider configuration

In the following example, the `google_compute_instance` resource selects the provider configuration with the `europe` alias. 

```hcl
provider "google" {
  region = "us-central1"
}

provider "google" {
  alias  = "europe"
  region = "europe-west1"
}

resource "google_compute_instance" "example" {  
  provider = google.europe
  # ...
}
```

### Ignore attribute changes

In the following example, Terraform ignores changes to tags attached to the resource:

```hcl
resource "aws_instance" "example" {
   # ...

   lifecycle {
      ignore_changes = [tags]
   }
}
```

### Specify triggers that replace resources

In the following example, Terraform replaces `aws_appautoscaling_target` each time this instance of `aws_ecs_service` is replaced:

```hcl
resource "aws_appautoscaling_target" "ecs_target" {
   ...
   lifecycle {
   replace_triggered_by = [ 
      aws_ecs_service.svc.id
     ]
   }
}
```

### Apply custom conditions

The following example includes several configurations that illustrate how to define `precondition` and `postcondition` arguments in the `lifecycle` meta-argument. 

The following `data` block instructs Terraform to retrieve the ID of the `ami-abc123` AMI:

```hcl
data "aws_ami" "example" {
  owners = ["amazon"]
  filter {
    name   = "image-id"
    values = ["ami-abc123"]
  }
}
```

In the following code, the `precondition` block specifies that the AMI ID retrieved from the `data` block must include `x86_64` as its `architecture` attribute. The `postcondition` block specifies that the EC2 instance must be allocated a public DNS hostname. When either condition is not met, Terraform returns the contents of the `error_message` for the failed condition:

```hcl
resource "aws_instance" "example" {
  instance_type = "t3.micro"
  ami           = data.aws_ami.example.id

  lifecycle {
    precondition {
      condition     = data.aws_ami.example.architecture == "x86_64"
      error_message = "The selected AMI must be for the x86_64 architecture."
    }

    postcondition {
      condition     = self.public_dns != ""
      error_message = "EC2 instance must be in a VPC that has public DNS hostnames enabled."
    }
  }
}
```

The following `data` block retrieves the root storage volume connected to the `aws_instance.example` EC2 instance using the `volume_id` attribute. When a `data` resource verifies the result of a managed resource declared in the same configuration, you must define the check in a `postcondition` block in the resource so that Terraform waits for changes to the managed resource to complete before reading the data resource.

```hcl
data "aws_ebs_volume" "example" {
  filter {
    name = "volume-id"
    values = [aws_instance.example.root_block_device[0].volume_id]
  }
  lifecycle {
    # The EC2 instance will have an encrypted root volume.
    postcondition {
      condition     = self.encrypted
      error_message = "The server's root volume is not encrypted."
    }
  }
}
output "api_base_url" {
  value = "https://${aws_instance.example.private_dns}:8433/"
}
```